<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis"></script>
  </head>
  <body>
    <script>
      async function visualizeData(points, featureName) {
        tfvis.render.scatterplot(
          { name: `${featureName} vs price` },
          { values: points, series: ["original"] },
          {
            xLabel: featureName,
            yValue: points
          }
        );
      }

      async function loadData() {
        return tf.data.csv("http://localhost:8080/kc_house_data.csv");
      }

      function normalize(tensor) {
        const max = tensor.max();
        const min = tensor.min();

        // value - min / max - min
        return {
          tensor: tensor.sub(min).div(max.sub(min)),
          min,
          max
        };
      }

      function desnormalize(tensor, min, max) {
        // ((max - min) * value) + min
        return tensor.mul(max.sub(min)).add(min);
      }

      function createModelForLinearRegression() {
        const model = tf.sequential();

        model.add(
          tf.layers.dense({ units: 1, inputDim: 1, activation: "linear" })
        );

        const optimizer = tf.train.sgd(0.1);
        // const optimizer = tf.train.adam();
        model.compile({
          loss: "meanSquaredError",
          optimizer
        });

        return model;
      }

      async function prepareData(data) {
        const pointsDataSet = data.map(d => ({
          x: d.sqft_living,
          y: d.price
        }));
        const points = await pointsDataSet.toArray();
        // cant be splitted in case there an even size of elements
        if (points.length % 2) {
          points.pop();
        }
        tf.util.shuffle(points);

        visualizeData(points, "Sqft Living");

        const values = points.map(p => p.x);
        // second param: data points and number of features (only sqft_living
        const valuesTensor = tf.tensor2d(values, [values.length, 1]);
        const {
          max: valuesMax,
          min: valuesMin,
          tensor: valuesTensorNormalized
        } = normalize(valuesTensor);

        const labels = points.map(p => p.y);
        // second param: data points and number of features (only price)
        const labelsTensor = tf.tensor2d(labels, [labels.length, 1]);
        const {
          max: labelsMax,
          min: labelsMin,
          tensor: labelsTensorNormalized
        } = normalize(tf.tensor2d(labels, [labels.length, 1]));

        const [trainingValuesTensor, testingValuesTensor] = tf.split(
          valuesTensorNormalized,
          2
        );
        const [trainingLabelsTensor, testingLabelsTensor] = tf.split(
          labelsTensorNormalized,
          2
        );

        return {
          values,
          labels,
          trainingValuesTensor,
          trainingLabelsTensor,
          testingValuesTensor,
          testingLabelsTensor
        };
      }

      async function trainModel(
        model,
        trainingFeaturesTensor,
        trainingLabelsTensor
      ) {
        const { onBatchEnd, onEpochEnd } = tfvis.show.fitCallbacks(
          { name: "Training Performance" },
          ["loss"]
        );

        return model.fit(trainingFeaturesTensor, trainingLabelsTensor, {
          epochs: 20,
          validationSplit: 0.2,
          callbacks: {
            onEpochEnd
            // onBatchEnd
          }
        });
      }

      async function run() {
        const data = await loadData();
        const model = createModelForLinearRegression();
        model.summary();
        tfvis.show.modelSummary({ name: "model" }, model);
        const layer = model.getLayer(undefined, 0);
        tfvis.show.layer({ name: "layer" }, layer);
        const {
          trainingValuesTensor,
          trainingLabelsTensor,
          testingValuesTensor,
          testingLabelsTensor
        } = await prepareData(data);
        const result = await trainModel(
          model,
          trainingValuesTensor,
          trainingLabelsTensor
        );
        const trainingLoss = result.history.loss.pop();
        console.log(`Training set loss: ${trainingLoss}`);

        const validationLoss = result.history.val_loss.pop();
        console.log(`Validation set loss: ${validationLoss}`);

        const lossTensor = model.evaluate(
          testingValuesTensor,
          testingLabelsTensor
        );
        const testingLoss = await lossTensor.dataSync();
        console.log(`Testing set loss: ${testingLoss}`);
      }

      run();
    </script>
  </body>
</html>
