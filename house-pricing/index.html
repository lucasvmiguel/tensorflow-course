<html>
  <head>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis"></script>
  </head>
  <body>
    <script>
      const MODEL_LOAD_PATH = "localstorage://model";
      let p;

      const visualizeData = (values, series, { title, xLabel, yLabel }) => {
        tfvis.render.scatterplot(
          { name: title },
          { values, series },
          {
            xLabel,
            yLabel
          }
        );
      };

      const visualizePointsAndPredictions = (
        model,
        {
          points,
          featureMinValue,
          featureMaxValue,
          labelMinValue,
          labelMaxValue,
          xLabel,
          yLabel
        }
      ) => {
        const prediction = predictionPoints(model, {
          featureMinValue,
          featureMaxValue,
          labelMinValue,
          labelMaxValue
        });
        visualizeData([points, prediction], [xLabel, "Prediction"], {
          title: `${xLabel} vs ${yLabel}`,
          xLabel,
          yLabel
        });
      };

      const predictionPoints = (
        model,
        { featureMinValue, featureMaxValue, labelMinValue, labelMaxValue }
      ) => {
        const normalizedXs = tf.linspace(0, 1, 100);
        const normalizedYs = model.predict(normalizedXs.reshape([100, 1]));

        const xs = desnormalize(
          normalizedXs,
          featureMinValue,
          featureMaxValue
        ).dataSync();
        const ys = desnormalize(
          normalizedYs,
          labelMinValue,
          labelMaxValue
        ).dataSync();

        return Array.from(xs).map((val, i) => ({
          x: val,
          y: ys[i]
        }));
      };

      const loadData = async () => {
        return tf.data.csv("http://localhost:8080/kc_house_data.csv");
      };

      const normalize = (tensor, pMin = null, pMax = null) => {
        const max = pMax || tensor.max();
        const min = pMin || tensor.min();

        // value - min / max - min
        return {
          tensor: tensor.sub(min).div(max.sub(min)),
          min,
          max
        };
      };

      const desnormalize = (tensor, min, max) => {
        // ((max - min) * value) + min
        return tensor.mul(max.sub(min)).add(min);
      };

      const createModelForLinearRegression = () => {
        const model = tf.sequential();

        model.add(
          tf.layers.dense({ units: 1, inputDim: 1, activation: "linear" })
        );

        const optimizer = tf.train.sgd(0.1);
        // const optimizer = tf.train.adam();
        model.compile({
          loss: "meanSquaredError",
          optimizer
        });

        return model;
      };

      const createModel = () => {
        model = tf.sequential();
        model.add(
          tf.layers.dense({
            units: 10,
            useBias: true,
            activation: "sigmoid",
            inputDim: 1
          })
        );
        model.add(
          tf.layers.dense({
            units: 10,
            useBias: true,
            activation: "sigmoid"
          })
        );
        model.add(
          tf.layers.dense({
            units: 1,
            useBias: true,
            activation: "sigmoid"
          })
        );
        const optimizer = tf.train.adam();
        model.compile({
          loss: "meanSquaredError",
          optimizer
        });
        return model;
      };

      const prepareData = async (data, field) => {
        const pointsDataSet = data.map(d => ({
          x: d[field],
          y: d.price
        }));
        const points = await pointsDataSet.toArray();
        // cant be splitted in case there an even size of elements
        if (points.length % 2) {
          points.pop();
        }
        tf.util.shuffle(points);

        const values = points.map(p => p.x);

        // second param: data points and number of features (only sqft_living)
        const valuesTensor = tf.tensor2d(values, [values.length, 1]);
        const {
          max: featureMaxValue,
          min: featureMinValue,
          tensor: valuesTensorNormalized
        } = normalize(valuesTensor);

        const labels = points.map(p => p.y);

        // second param: data points and number of features (only price)
        const labelsTensor = tf.tensor2d(labels, [labels.length, 1]);
        const {
          max: labelMaxValue,
          min: labelMinValue,
          tensor: labelsTensorNormalized
        } = normalize(tf.tensor2d(labels, [labels.length, 1]));

        const [trainingValuesTensor, testingValuesTensor] = tf.split(
          valuesTensorNormalized,
          2
        );
        const [trainingLabelsTensor, testingLabelsTensor] = tf.split(
          labelsTensorNormalized,
          2
        );

        return {
          points,
          trainingValuesTensor,
          trainingLabelsTensor,
          testingValuesTensor,
          testingLabelsTensor,
          labelMinValue,
          labelMaxValue,
          featureMinValue,
          featureMaxValue
        };
      };

      const trainModel = async (
        model,
        featureTensor,
        labelTensor,
        {
          featureMinValue,
          featureMaxValue,
          labelMinValue,
          labelMaxValue,
          onEpochEnd
        }
      ) => {
        const result = await model.fit(featureTensor, labelTensor, {
          epochs: 100,
          validationSplit: 0.2,
          callbacks: {
            onEpochEnd
          }
        });

        return result;
      };

      const predict = (
        model,
        value,
        { featureMinValue, featureMaxValue, labelMinValue, labelMaxValue }
      ) => {
        const tensorPredict = tf.tensor1d([value]);
        const normalizedInput = normalize(
          tensorPredict,
          featureMinValue,
          featureMaxValue
        );

        const normalizedPrediction = model.predict(normalizedInput.tensor);

        const predictionTensor = desnormalize(
          normalizedPrediction,
          labelMinValue,
          labelMaxValue
        );
        return predictionTensor.dataSync()[0];
      };

      async function run() {
        const field = "sqft_living";
        const data = await loadData();
        const model = createModel();
        tfvis.show.modelSummary({ name: "model" }, model);

        const {
          points,
          trainingValuesTensor,
          trainingLabelsTensor,
          testingValuesTensor,
          testingLabelsTensor,
          labelMaxValue,
          labelMinValue,
          featureMaxValue,
          featureMinValue
        } = await prepareData(data, field);

        const result = await trainModel(
          model,
          trainingValuesTensor,
          trainingLabelsTensor,
          {
            featureMinValue,
            featureMaxValue,
            labelMinValue,
            labelMaxValue,
            onEpochEnd: (_, logs) => {
              console.log(logs);

              tfvis.show.layer(
                { name: "layer 1" },
                model.getLayer(undefined, 0)
              );
              tfvis.show.layer(
                { name: "layer 2" },
                model.getLayer(undefined, 1)
              );
              tfvis.show.layer(
                { name: "layer 3" },
                model.getLayer(undefined, 2)
              );

              visualizePointsAndPredictions(model, {
                points,
                featureMinValue,
                featureMaxValue,
                labelMinValue,
                labelMaxValue,
                xLabel: field,
                yLabel: "Price"
              });
            }
          }
        );
        // const trainingLoss = result.history.loss.pop();
        // console.log(`Training set loss: ${trainingLoss}`);

        // const validationLoss = result.history.val_loss.pop();
        // console.log(`Validation set loss: ${validationLoss}`);

        // const lossTensor = model.evaluate(
        //   testingValuesTensor,
        //   testingLabelsTensor
        // );
        // const testingLoss = await lossTensor.dataSync();
        // console.log(`Testing set loss: ${testingLoss}`);

        p = value =>
          predict(model, value, {
            featureMinValue,
            featureMaxValue,
            labelMinValue,
            labelMaxValue
          });
      }

      run();
    </script>
  </body>
</html>
